
from multiprocessing import Process

def worker(money):
    print("开始干活")
    print(f"拿到{money}块工资")

# 通过target指定进程具体执行的工作-传入对应函数，args参数执行传入函数的参数，需要注意这里是元组类型的
if __name__ == '__main__':
    process = Process(target=worker, args=(100,))
    process.start()
    process.join()

'''
当 Python 程序启动时，它会先进行一系列的初始化操作，也就是所谓的 “bootstrapping phase（引导阶段）”。在这个阶段还没完成的时候，如果尝试去启动新的进程，就会触发这个错误。
通常情况下，在 Windows 系统中，Python 解释器需要确保模块的顶层可执行代码被正确地保护起来，避免一些重复导入等可能导致的问题，这就要求将创建进程相关的代码放在 if __name__ == '__main__': 语句块内。因为在多进程启动时，子进程会重新导入整个模块，如果没有这个保护机制，模块中的代码可能会被多次执行，从而引发混乱，比如出现重复创建进程等不符合预期的情况。
需要将创建 Process 以及启动、管理进程相关的代码放在 if __name__ == '__main__': 语句块里面，
'''


'''
多进程的主要优势在于能够绕过GIL的限制，利用多核CPU实现真正的并行计算，特别适合处理CPU密集型任务。


其劣势在于运行一个进程消耗的资源比线程多很多，进程间的通讯也是比较复杂（比如需要用到消息队列、管道等机制）


最后总结一句话：对于CPU密集型任务选择多进程，对于IO密集型任务选择多线程。
'''